import { UnwrapRef } from '@vue/composition-api';
import { Pinia } from './rootStore';
/**
 * Generic state of a Store
 */
export declare type StateTree = Record<string | number | symbol, any>;
/**
 * Object descriptor for Object.defineProperty
 */
export interface StateDescriptor<S extends StateTree> {
    get(): S;
    set(newValue: S): void;
}
export declare function isPlainObject(o: any): o is StateTree;
export declare type DeepPartial<T> = {
    [K in keyof T]?: DeepPartial<T[K]>;
};
/**
 * Possible types for SubscriptionCallback
 */
export declare enum MutationType {
    /**
     * Direct mutation of the state:
     *
     * - `store.name = 'new name'`
     * - `store.$state.name = 'new name'`
     * - `store.list.push('new item')`
     */
    direct = "direct",
    /**
     * Mutated the state with `$patch` and an object
     *
     * - `store.$patch({ name: 'newName' })`
     */
    patchObject = "patch object",
    /**
     * Mutated the state with `$patch` and a function
     *
     * - `store.$patch(state => state.name = 'newName')`
     */
    patchFunction = "patch function"
}
/**
 * Base type for the context passed to a subscription callback.
 *
 * @internal
 */
export interface _SubscriptionCallbackMutationBase {
    /**
     * Type of the mutation.
     */
    type: MutationType;
    /**
     * @deprecated use `storeId` instead.
     */
    storeName: string;
    /**
     * `id` of the store doing the mutation.
     */
    storeId: string;
}
/**
 * Context passed to a subscription callback when directly mutating the state of
 * a store with `store.someState = newValue` or `store.$state.someState =
 * newValue`.
 */
export interface SubscriptionCallbackMutationDirect extends _SubscriptionCallbackMutationBase {
    type: MutationType.direct;
}
/**
 * Context passed to a subscription callback when `store.$patch()` is called
 * with an object.
 */
export interface SubscriptionCallbackMutationPatchObject<S> extends _SubscriptionCallbackMutationBase {
    type: MutationType.patchObject;
    /**
     * Object passed to `store.$patch()`.
     */
    payload: DeepPartial<S>;
}
/**
 * Context passed to a subscription callback when `store.$patch()` is called
 * with a function.
 */
export interface SubscriptionCallbackMutationPatchFunction extends _SubscriptionCallbackMutationBase {
    type: MutationType.patchFunction;
}
/**
 * Context object passed to a subscription callback.
 */
export declare type SubscriptionCallbackMutation<S> = SubscriptionCallbackMutationDirect | SubscriptionCallbackMutationPatchObject<S> | SubscriptionCallbackMutationPatchFunction;
export declare type UnwrapPromise<T> = T extends Promise<infer V> ? V : T;
/**
 * Callback of a subscription
 */
export declare type SubscriptionCallback<S> = (
/**
 * Object with information relative to the store mutation that triggered the
 * subscription.
 */
mutation: SubscriptionCallbackMutation<S>, 
/**
 * State of the store when the subscription is triggered. Same as
 * `store.$state`.
 */
state: UnwrapRef<S>) => void;
/**
 * Context object passed to callbacks of `store.$onAction(context => {})`
 */
export declare type StoreOnActionListenerContext<Id extends string, S extends StateTree, G extends GettersTree<S>, A> = {
    [Name in keyof A]: {
        /**
         * Name of the action
         */
        name: Name;
        /**
         * Store that is invoking the action
         */
        store: Store<Id, S, G, A>;
        /**
         * Parameters passed to the action
         */
        args: A[Name] extends _Method ? Parameters<A[Name]> : unknown[];
        /**
         * Sets up a hook once the action is finished. It receives the return value of
         * the action, if it's a Promise, it will be unwrapped.
         */
        after: (callback: A[Name] extends _Method ? (resolvedReturn: UnwrapPromise<ReturnType<A[Name]>>) => void : () => void) => void;
        /**
         * Sets up a hook if the action fails.
         */
        onError: (callback: (error: unknown) => void) => void;
    };
}[keyof A];
/**
 * Argument of `store.$onAction()`
 */
export declare type StoreOnActionListener<Id extends string = string, S extends StateTree = StateTree, G extends GettersTree<S> = GettersTree<S>, A = ActionsTree> = (context: StoreOnActionListenerContext<Id, S, G, A>) => void;
/**
 * Base store with state and functions
 * @internal
 */
export interface StoreWithState<Id extends string, S extends StateTree, G extends GettersTree<StateTree> = GettersTree<S>, A = ActionsTree> {
    /**
     * Unique identifier of the store
     */
    $id: Id;
    /**
     * State of the Store. Setting it will replace the whole state.
     */
    $state: UnwrapRef<StateTree extends S ? {} : S> & PiniaCustomStateProperties<S>;
    /**
     * Private property defining the pinia the store is attached to.
     *
     * @internal
     */
    _p: Pinia;
    /**
     * Applies a state patch to current state. Allows passing nested values
     * @param partialState - patch to apply to the state
     */
    $patch(partialState: DeepPartial<UnwrapRef<S>>): void;
    /**
     * Group multiple changes into one function. Useful when mutating objects like
     * Sets or arrays and applying an object patch isn't practical, e.g. appending
     * to an array.
     *
     * @param stateMutator - function that mutates `state`, cannot be async
     */
    $patch<F extends (state: UnwrapRef<S>) => void>(stateMutator: ReturnType<F> extends Promise<any> ? never : F): void;
    /**
     * Resets the store to its initial state by building a new state object.
     */
    $reset(): void;
    /**
     * Setups a callback to be called whenever the state changes. It also returns
     * a function to remove the callback. Note than when calling
     * `store.$subscribe()` inside of a component, it will be automatically
     * cleanup up when the component gets unmounted.
     *
     * @param callback - callback passed to the watcher
     * @returns function that removes the watcher
     */
    $subscribe(callback: SubscriptionCallback<S>): () => void;
    /**
     * Array of registered action subscriptions.Set without the generics to avoid
     * errors between the generic version of Store and specific stores.
     *
     * @internal
     */
    _as: StoreOnActionListener[];
    /**
     * @alpha Please send feedback at https://github.com/posva/pinia/issues/240
     * Setups a callback to be called every time an action is about to get
     * invoked. The callback receives an object with all the relevant information
     * of the invoked action:
     * - `store`: the store it is invoked on
     * - `name`: The name of the action
     * - `args`: The parameters passed to the action
     *
     * On top of these, it receives two functions that allow setting up a callback
     * once the action finishes or when it fails.
     *
     * It also returns a function to remove the callback. Note than when calling
     * `store.$onAction()` inside of a component, it will be automatically cleanup
     * up when the component gets unmounted.
     *
     * @example
     *
     *```js
     *store.$onAction(({ after, onError }) => {
     *  // Here you could share variables between all of the hooks as well as
     *  // setting up watchers and clean them up
     *  after(() => {
     *    // can be used to cleanup side effects
     *  })
     *  onError((error) => {
     *    // can be used to pass up errors
     *  })
     *})
     *```
     *
     * @param callback - callback called before every action
     * @returns function that removes the watcher
     */
    $onAction(callback: StoreOnActionListener<Id, S, G, A>): () => void;
}
/**
 * Generic type for a function that can infer arguments and return type
 *
 * @internal
 */
export declare type _Method = (...args: any[]) => any;
/**
 * Store augmented for actions
 *
 * @internal
 */
export declare type StoreWithActions<A> = {
    [k in keyof A]: A[k] extends (...args: infer P) => infer R ? (...args: P) => R : never;
};
/**
 * Store augmented with getters
 *
 * @internal
 */
export declare type StoreWithGetters<G> = {
    readonly [k in keyof G]: G[k] extends (...args: any[]) => infer R ? R : never;
};
/**
 * Store type to build a store
 */
export declare type Store<Id extends string = string, S extends StateTree = StateTree, G extends GettersTree<S> = GettersTree<S>, A = ActionsTree> = StoreWithState<Id, StateTree extends S ? {} : S, G, A> & (StateTree extends S ? {} : UnwrapRef<S>) & (GettersTree<S> extends G ? {} : StoreWithGetters<G>) & (ActionsTree extends A ? {} : StoreWithActions<A>) & PiniaCustomProperties<Id, S, G, A> & PiniaCustomStateProperties<S>;
/**
 * Generic and type-unsafe version of Store. Doesn't fail on access with
 * strings, making it much easier to write generic functions that do not care
 * about the kind of store that is passed.
 */
export declare type GenericStore<Id extends string = string, S extends StateTree = any, G extends GettersTree<S> = GettersTree<S>, A = ActionsTree> = StoreWithState<Id, S, G, A> & UnwrapRef<S> & StoreWithGetters<G> & StoreWithActions<A> & PiniaCustomProperties<Id, S, G, A> & PiniaCustomStateProperties<S>;
/**
 * Return type of `defineStore()`. Function that allows instantiating a store.
 */
export interface StoreDefinition<Id extends string, S extends StateTree, G extends GettersTree<S>, A> {
    /**
     * Returns a store, creates it if necessary.
     *
     * @param pinia - Pinia instance to retrieve the store
     */
    (pinia?: Pinia | null | undefined): Store<Id, S, G, A>;
    /**
     * Id of the store. Used by map helpers.
     */
    $id: Id;
}
/**
 * Properties that are added to every store by `pinia.use()`
 */
export interface PiniaCustomProperties<Id extends string = string, S extends StateTree = StateTree, G extends GettersTree<S> = GettersTree<S>, A = ActionsTree> {
}
/**
 * Properties that are added to every `store.$state` by `pinia.use()`
 */
export interface PiniaCustomStateProperties<S extends StateTree = StateTree> {
}
/**
 * Type of an object of Getters that infers the argument
 *
 * @internal
 */
export declare type GettersTree<S extends StateTree> = Record<string, ((state: UnwrapRef<(StateTree extends S ? {} : S) & PiniaCustomStateProperties<S>>) => any) | (() => any)>;
/**
 * @internal
 */
export declare type ActionsTree = Record<string, _Method>;
/**
 * Options parameter of `defineStore()`. Can be extended to augment stores with
 * the plugin API.
 */
export interface DefineStoreOptions<Id extends string, S extends StateTree, G extends GettersTree<S>, A> {
    /**
     * Unique string key to identify the store across the application.
     */
    id: Id;
    /**
     * Function to create a fresh state.
     */
    state?: () => S;
    /**
     * Optional object of getters.
     */
    getters?: G & ThisType<UnwrapRef<StateTree extends S ? {} : S> & StoreWithGetters<G> & PiniaCustomProperties>;
    /**
     * Optional object of actions.
     */
    actions?: A & ThisType<A & UnwrapRef<StateTree extends S ? {} : S> & StoreWithState<Id, S, G, A> & StoreWithGetters<GettersTree<S> extends G ? {} : G> & PiniaCustomProperties>;
}
//# sourceMappingURL=types.d.ts.map