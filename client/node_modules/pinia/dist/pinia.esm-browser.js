/*!
  * pinia v0.5.4
  * (c) 2021 Eduardo San Martin Morote
  * @license MIT
  */
import { ref, markRaw, getCurrentInstance, inject, provide, set, computed, reactive, watch, onUnmounted, isRef, isReactive } from '@vue/composition-api';

/**
 * The api needs more work we must be able to use the store easily in any
 * function by calling `useStore` to get the store Instance and we also need to
 * be able to reset the store instance between requests on the server
 */
const storesMap = new WeakMap();
const piniaSymbol = (Symbol('pinia') );
/**
 * Creates a Pinia instance to be used by the application
 */
function createPinia() {
    // NOTE: here we could check the window object for a state and directly set it
    // if there is anything like it with Vue 3 SSR
    const state = ref({});
    const _p = [];
    const pinia = markRaw({
        use(plugin) {
            _p.push(plugin);
            return pinia;
        },
        _p,
        state,
    });
    // this allows calling useStore() outside of a component setup after
    // installing pinia's plugin
    setActivePinia(pinia);
    return pinia;
}
/**
 * setActivePinia must be called to handle SSR at the top of functions like
 * `fetch`, `setup`, `serverPrefetch` and others
 */
let activePinia;
/**
 * Sets or unsets the active pinia. Used in SSR and internally when calling
 * actions and getters
 *
 * @param pinia - Pinia instance
 */
const setActivePinia = (pinia) => (activePinia = pinia);
/**
 * Get the currently active pinia
 */
const getActivePinia = () => {
    /* istanbul ignore if */
    if (!activePinia) {
        console.warn(`[üçç]: getActivePinia was called with no active Pinia. Did you forget to install pinia and inject it?\n\n` +
            `import { PiniaPlugin, createPinia } from 'pinia'\n\n` +
            `Vue.use(PiniaPlugin)\n` +
            `const pinia = createPinia()\n` +
            `new Vue({ el: '#app', pinia })\n\n` +
            `This will fail in production.`);
    }
    return activePinia;
};

function isPlainObject(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
o) {
    return (o &&
        typeof o === 'object' &&
        Object.prototype.toString.call(o) === '[object Object]' &&
        typeof o.toJSON !== 'function');
}
// type DeepReadonly<T> = { readonly [P in keyof T]: DeepReadonly<T[P]> }
/**
 * Possible types for SubscriptionCallback
 */
var MutationType;
(function (MutationType) {
    /**
     * Direct mutation of the state:
     *
     * - `store.name = 'new name'`
     * - `store.$state.name = 'new name'`
     * - `store.list.push('new item')`
     */
    MutationType["direct"] = "direct";
    /**
     * Mutated the state with `$patch` and an object
     *
     * - `store.$patch({ name: 'newName' })`
     */
    MutationType["patchObject"] = "patch object";
    /**
     * Mutated the state with `$patch` and a function
     *
     * - `store.$patch(state => state.name = 'newName')`
     */
    MutationType["patchFunction"] = "patch function";
    // maybe reset? for $state = {} and $reset
})(MutationType || (MutationType = {}));

const target = typeof window !== 'undefined'
    ? window
    : typeof global !== 'undefined'
        ? global
        : { __VUE_DEVTOOLS_GLOBAL_HOOK__: undefined };
// @ts-ignore
const devtoolHook = target.__VUE_DEVTOOLS_GLOBAL_HOOK__;
let rootStore;
function useStoreDevtools(store, stateDescriptor) {
    if (!devtoolHook)
        return;
    if (!rootStore) {
        rootStore = {
            _devtoolHook: devtoolHook,
            _vm: { $options: { computed: {} } },
            _mutations: {},
            // we need to store modules names
            _modulesNamespaceMap: {},
            _modules: {
                // we only need this specific method to let devtools retrieve the module name
                get(name) {
                    return name in rootStore._modulesNamespaceMap;
                },
            },
            state: {},
            replaceState: () => {
                // we handle replacing per store so we do nothing here
            },
            // these are used by the devtools
            registerModule: () => { },
            unregisterModule: () => { },
        };
        devtoolHook.emit('vuex:init', rootStore);
    }
    // tell the devtools we added a module
    rootStore.registerModule(store.$id, store);
    Object.defineProperty(rootStore.state, store.$id, {
        enumerable: true,
        ...stateDescriptor,
    });
    // Vue.set(rootStore.state, store.name, store.state)
    // the trailing slash is removed by the devtools
    rootStore._modulesNamespaceMap[store.$id + '/'] = true;
    devtoolHook.on('vuex:travel-to-state', (targetState) => {
        stateDescriptor.set(targetState[store.$id]);
    });
    store.$subscribe((mutation, state) => {
        rootStore.state[store.$id] = state;
        devtoolHook.emit('vuex:mutation', {
            type: `[${mutation.storeId}] ${mutation.type}`,
            // @ts-expect-error: will be undefined in worst case
            payload: mutation.payload,
        }, 
        // this doesn't seem to be used by the devtools but it's in vuex codebase
        rootStore.state);
    });
}

const assign = Object.assign;

const isClient = typeof window != 'undefined';
function innerPatch(target, patchToApply) {
    // TODO: get all keys like symbols as well
    for (const key in patchToApply) {
        const subPatch = patchToApply[key];
        const targetValue = target[key];
        if (isPlainObject(targetValue) &&
            isPlainObject(subPatch) &&
            !isRef(subPatch) &&
            !isReactive(subPatch)) {
            target[key] = innerPatch(targetValue, subPatch);
        }
        else {
            // @ts-expect-error
            target[key] = subPatch;
        }
    }
    return target;
}
/**
 * Create an object of computed properties referring to
 *
 * @param rootStateRef - pinia.state
 * @param id - unique name
 */
function computedFromState(rootStateRef, id) {
    // let asComputed = computed<T>()
    const reactiveObject = {};
    const state = rootStateRef.value[id];
    for (const key in state) {
        // @ts-expect-error: the key matches
        reactiveObject[key] = computed({
            get: () => rootStateRef.value[id][key],
            set: (value) => (rootStateRef.value[id][key] = value),
        });
    }
    return reactiveObject;
}
/**
 * Creates a store with its state object. This is meant to be augmented with getters and actions
 *
 * @param $id - unique identifier of the store, like a name. eg: main, cart, user
 * @param buildState - function to build the initial state
 * @param initialState - initial state applied to the store, Must be correctly typed to infer typings
 */
function initStore($id, buildState = () => ({}), initialState) {
    const pinia = getActivePinia();
    set(pinia.state.value, $id, initialState || buildState());
    // const state: Ref<S> = toRef(_p.state.value, $id)
    let isListening = true;
    const subscriptions = [];
    const actionSubscriptions = [];
    function $patch(partialStateOrMutator) {
        let subscriptionMutation;
        isListening = false;
        if (typeof partialStateOrMutator === 'function') {
            partialStateOrMutator(pinia.state.value[$id]);
            subscriptionMutation = {
                type: MutationType.patchFunction,
                storeName: $id,
                storeId: $id,
            };
        }
        else {
            innerPatch(pinia.state.value[$id], partialStateOrMutator);
            subscriptionMutation = {
                type: MutationType.patchObject,
                payload: partialStateOrMutator,
                storeName: $id,
                storeId: $id,
            };
        }
        isListening = true;
        // because we paused the watcher, we need to manually call the subscriptions
        subscriptions.forEach((callback) => {
            callback(subscriptionMutation, pinia.state.value[$id]);
        });
    }
    function $subscribe(callback) {
        subscriptions.push(callback);
        // watch here to link the subscription to the current active instance
        // e.g. inside the setup of a component
        const stopWatcher = watch(() => pinia.state.value[$id], (state) => {
            if (isListening) {
                callback({
                    storeName: $id,
                    storeId: $id,
                    type: MutationType.direct,
                }, state);
            }
        }, {
            deep: true,
            flush: 'sync',
        });
        const removeSubscription = () => {
            const idx = subscriptions.indexOf(callback);
            if (idx > -1) {
                subscriptions.splice(idx, 1);
                stopWatcher();
            }
        };
        if (getCurrentInstance()) {
            onUnmounted(removeSubscription);
        }
        return removeSubscription;
    }
    function $onAction(callback) {
        actionSubscriptions.push(callback);
        const removeSubscription = () => {
            const idx = actionSubscriptions.indexOf(callback);
            if (idx > -1) {
                actionSubscriptions.splice(idx, 1);
            }
        };
        if (getCurrentInstance()) {
            onUnmounted(removeSubscription);
        }
        return removeSubscription;
    }
    function $reset() {
        pinia.state.value[$id] = buildState();
    }
    const storeWithState = {
        $id,
        _p: pinia,
        _as: markRaw(actionSubscriptions),
        // $state is added underneath
        $patch,
        $subscribe,
        $onAction,
        $reset,
    };
    const injectionSymbol = Symbol(`PiniaStore(${$id})`)
        ;
    return [
        storeWithState,
        {
            get: () => pinia.state.value[$id],
            set: (newState) => {
                isListening = false;
                pinia.state.value[$id] = newState;
                isListening = true;
            },
        },
        injectionSymbol,
    ];
}
const noop = () => { };
/**
 * Creates a store bound to the lifespan of where the function is called. This
 * means creating the store inside of a component's setup will bound it to the
 * lifespan of that component while creating it outside of a component will
 * create an ever living store
 *
 * @param partialStore - store with state returned by initStore
 * @param descriptor - descriptor to setup $state property
 * @param $id - unique name of the store
 * @param getters - getters of the store
 * @param actions - actions of the store
 */
function buildStoreToUse(partialStore, descriptor, $id, getters = {}, actions = {}, options) {
    const pinia = getActivePinia();
    const computedGetters = {};
    for (const getterName in getters) {
        // @ts-expect-error: it's only readonly for the users
        computedGetters[getterName] = computed(() => {
            setActivePinia(pinia);
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            // @ts-expect-error: the argument count is correct
            return getters[getterName].call(store, store);
        });
    }
    const wrappedActions = {};
    for (const actionName in actions) {
        wrappedActions[actionName] = function () {
            setActivePinia(pinia);
            /* eslint-disable-next-line */
            const args = Array.from(arguments);
            const localStore = this || store;
            let afterCallback = noop;
            let onErrorCallback = noop;
            function after(callback) {
                afterCallback = callback;
            }
            function onError(callback) {
                onErrorCallback = callback;
            }
            partialStore._as.forEach((callback) => {
                callback({
                    args,
                    name: actionName,
                    // @ts-expect-error
                    store: localStore,
                    after,
                    onError,
                });
            });
            let ret;
            try {
                ret = actions[actionName].apply(localStore, args);
                Promise.resolve(ret).then(afterCallback).catch(onErrorCallback);
            }
            catch (error) {
                onErrorCallback(error);
                throw error;
            }
            return ret;
        };
    }
    const store = reactive(assign({}, partialStore, 
    // using this means no new properties can be added as state
    computedFromState(pinia.state, $id), computedGetters, wrappedActions));
    // use this instead of a computed with setter to be able to create it anywhere
    // without linking the computed lifespan to wherever the store is first
    // created.
    Object.defineProperty(store, '$state', descriptor);
    // apply all plugins
    pinia._p.forEach((extender) => {
        // @ts-expect-error: conflict between A and ActionsTree
        assign(store, extender({ store, pinia, options }));
    });
    return store;
}
/**
 * Defines a `useStore()` function that creates or retrieves the store instance
 * when called.
 *
 * @param options
 */
function defineStore(options) {
    const { id, state, getters, actions } = options;
    function useStore(pinia) {
        const hasInstance = getCurrentInstance();
        // only run provide when pinia hasn't been manually passed
        const shouldProvide = hasInstance && !pinia;
        // pinia = pinia || (vm && ((vm as any).$pinia as Pinia))
        pinia = pinia || (hasInstance && inject(piniaSymbol));
        if (pinia)
            setActivePinia(pinia);
        pinia = getActivePinia();
        let storeCache = storesMap.get(pinia);
        if (!storeCache)
            storesMap.set(pinia, (storeCache = new Map()));
        let storeAndDescriptor = storeCache.get(id);
        if (!storeAndDescriptor) {
            storeAndDescriptor = initStore(id, state, pinia.state.value[id]);
            // @ts-expect-error: annoying to type
            storeCache.set(id, storeAndDescriptor);
            if (isClient) {
                // @ts-expect-error: annoying to type
                useStoreDevtools(storeAndDescriptor[0], storeAndDescriptor[1]);
            }
            const store = buildStoreToUse(storeAndDescriptor[0], storeAndDescriptor[1], id, getters, actions, options);
            // allow children to reuse this store instance to avoid creating a new
            // store for each child
            if (shouldProvide) {
                provide(storeAndDescriptor[2], store);
            }
            return store;
        }
        return ((hasInstance && inject(storeAndDescriptor[2], null)) ||
            buildStoreToUse(storeAndDescriptor[0], storeAndDescriptor[1], id, getters, actions, options));
    }
    // needed by map helpers
    useStore.$id = id;
    return useStore;
}

/**
 * Vue Plugin that must be installed for pinia to work. Note **you don't need
 * this plugin if you are using Nuxt.js**. Use the `buildModule` instead:
 * https://pinia.esm.dev/ssr/nuxt.html.
 *
 * @example
 * ```js
 * import Vue from 'vue'
 * import { PiniaPlugin, createPinia } from 'pinia'
 *
 * Vue.use(PiniaPlugin)
 * const pinia = createPinia()
 *
 * new Vue({
 *   el: '#app',
 *   // ...
 *   pinia,
 * })
 * ```
 *
 * @param _Vue
 */
const PiniaPlugin = function (_Vue) {
    // Equivalent of
    // app.config.globalProperties.$pinia = pinia
    _Vue.mixin({
        beforeCreate() {
            const options = this.$options;
            if (options.pinia) {
                // HACK: taken from provide(): https://github.com/vuejs/composition-api/blob/master/src/apis/inject.ts#L25
                /* istanbul ignore else */
                if (!this._provided) {
                    const provideCache = {};
                    Object.defineProperty(this, '_provided', {
                        get: () => provideCache,
                        set: (v) => Object.assign(provideCache, v),
                    });
                }
                this._provided[piniaSymbol] = options.pinia;
                // propagate the pinia instance in an SSR friendly way
                // avoid adding it to nuxt twice
                /* istanbul ignore else */
                if (!this.$pinia) {
                    this.$pinia = options.pinia;
                }
            }
            else if (!this.$pinia && options.parent && options.parent.$pinia) {
                this.$pinia = options.parent.$pinia;
            }
        },
        destroyed() {
            // @ts-expect-error: clear up the store cache
            delete this._pStores;
        },
    });
};

function getCachedStore(vm, useStore) {
    const cache = '_pStores' in vm ? vm._pStores : (vm._pStores = {});
    const id = useStore.$id;
    // @ts-expect-error: again the Id to string fail
    return (cache[id] || (cache[id] = useStore(vm.$pinia)));
}
let mapStoreSuffix = 'Store';
/**
 * Changes the suffix added by `mapStores()`. Can be set to an empty string.
 * Defaults to `"Store"`. Make sure to extend the MapStoresCustomization
 * interface if you need are using TypeScript.
 *
 * @param suffix - new suffix
 */
function setMapStoreSuffix(suffix // could be 'Store' but that would be annoying for JS
) {
    mapStoreSuffix = suffix;
}
/**
 * Allows using stores without the composition API (`setup()`) by generating an
 * object to be spread in the `computed` field of a component. It accepts a list
 * of store definitions.
 *
 * @example
 * ```js
 * export default {
 *   computed: {
 *     // other computed properties
 *     ...mapStores(useUserStore, useCartStore)
 *   },
 *
 *   created() {
 *     this.userStore // store with id "user"
 *     this.cartStore // store with id "cart"
 *   }
 * }
 * ```
 *
 * @param stores - list of stores to map to an object
 */
function mapStores(...stores) {
    if (Array.isArray(stores[0])) {
        console.warn(`[üçç]: Directly pass all stores to "mapStores()" without putting them in an array:\n` +
            `Replace\n` +
            `\tmapStores([useAuthStore, useCartStore])\n` +
            `with\n` +
            `\tmapStores(useAuthStore, useCartStore)\n` +
            `This will fail in production if not fixed.`);
        stores = stores[0];
    }
    return stores.reduce((reduced, useStore) => {
        // @ts-expect-error: $id is added by defineStore
        reduced[useStore.$id + mapStoreSuffix] = function () {
            return getCachedStore(this, useStore);
        };
        return reduced;
    }, {});
}
/**
 * Allows using state and getters from one store without using the composition
 * API (`setup()`) by generating an object to be spread in the `computed` field
 * of a component.
 *
 * @param useStore - store to map from
 * @param keysOrMapper - array or object
 */
function mapState(useStore, keysOrMapper) {
    return Array.isArray(keysOrMapper)
        ? keysOrMapper.reduce((reduced, key) => {
            reduced[key] = function () {
                // @ts-expect-error
                return getCachedStore(this, useStore)[key];
            };
            return reduced;
        }, {})
        : Object.keys(keysOrMapper).reduce((reduced, key) => {
            reduced[key] = function () {
                const store = getCachedStore(this, useStore);
                const storeKey = keysOrMapper[key];
                // for some reason TS is unable to infer the type of storeKey to be a
                // function
                return typeof storeKey === 'function'
                    ? storeKey.call(this, store)
                    : store[storeKey];
            };
            return reduced;
        }, {});
}
/**
 * Alias for `mapState()`. You should use `mapState()` instead.
 * @deprecated use `mapState()` instead.
 */
const mapGetters = mapState;
/**
 * Allows directly using actions from your store without using the composition
 * API (`setup()`) by generating an object to be spread in the `methods` field
 * of a component.
 *
 * @param useStore - store to map from
 * @param keysOrMapper - array or object
 */
function mapActions(useStore, keysOrMapper) {
    return Array.isArray(keysOrMapper)
        ? keysOrMapper.reduce((reduced, key) => {
            // @ts-expect-error
            reduced[key] = function (...args) {
                // @ts-expect-error
                return getCachedStore(this, useStore)[key](...args);
            };
            return reduced;
        }, {})
        : Object.keys(keysOrMapper).reduce((reduced, key) => {
            // @ts-expect-error
            reduced[key] = function (...args) {
                // @ts-expect-error
                return getCachedStore(this, useStore)[keysOrMapper[key]](...args);
            };
            return reduced;
        }, {});
}
/**
 * Allows using state and getters from one store without using the composition
 * API (`setup()`) by generating an object to be spread in the `computed` field
 * of a component.
 *
 * @param useStore - store to map from
 * @param keysOrMapper - array or object
 */
function mapWritableState(useStore, keysOrMapper) {
    return Array.isArray(keysOrMapper)
        ? keysOrMapper.reduce((reduced, key) => {
            reduced[key] = {
                get() {
                    // @ts-expect-error
                    return getCachedStore(this, useStore)[key];
                },
                set(value) {
                    // it's easier to type it here as any
                    // @ts-expect-error
                    return (getCachedStore(this, useStore)[key] = value);
                },
            };
            return reduced;
        }, {})
        : Object.keys(keysOrMapper).reduce((reduced, key) => {
            reduced[key] = {
                get() {
                    // @ts-expect-error
                    return getCachedStore(this, useStore)[keysOrMapper[key]];
                },
                set(value) {
                    // it's easier to type it here as any
                    // @ts-expect-error
                    return (getCachedStore(this, useStore)[keysOrMapper[key]] =
                        value);
                },
            };
            return reduced;
        }, {});
}

/**
 * {@inheritDoc defineStore}
 * @deprecated Use {@link defineStore}
 */
const createStore = ((options) => {
    console.warn('[üçç]: "createStore" has been deprecated and will be removed on the sable release, use "defineStore" instead.');
    return defineStore(options);
});

export { MutationType, PiniaPlugin, createPinia, createStore, defineStore, mapActions, mapGetters, mapState, mapStores, mapWritableState, setActivePinia, setMapStoreSuffix };
